<!doctype html>
<html>
<head>

</head>
<body>

<main>
    <header>
        <h1><small>Out of Control</small><br /><span style="color:brown">Cave</span> <span style="color:limegreen">Lander</span></h1>
        <button onclick="start()">Play</button>
        <p>
            <code>Scroll Wheel</code> Rotate your lander!
            <br /><code>Click</code> Dismiss messages
            <br /><small>A Game by and &copy; <a href="https://somethinghere.net">Something Here</a>
            <br />Made for GMTK Game Jam 2020</small>
        </p>
    </header>
    <section id="game"></section>
    <aside>
        <span id="points-counter">0</span>
        <span id="control-visualiser"></span>
        <span id="progress-visualiser"></span>
        <span id="health-visualiser"></span>
    </aside>
</main>

<style>
@import url('https://fonts.googleapis.com/css2?family=Vampiro+One&family=Major+Mono+Display&display=swap');

@keyframes fadein {
    from { opacity: 0; }
}
@keyframes button {
    from { background-position: right -140px top 0; }
    to { background-position: left -140px top 0; }
}
@keyframes playbutton {
    from { transform: var(--skew) scale(.9) rotate(0deg); }
    30% { transform: var(--skew) scale(.9) rotate(1440deg); }
    40% { transform: var(--skew) scale(.9) rotate(1450deg); }
    to { transform: var(--skew) scale(.9) rotate(1440deg); }
}
@keyframes message {
    from { transform: translateX(100vw) scale(.75); opacity: .5; }
    20% { transform: translateX(0) scale(.75); opacity: 1; }
    40% { transform: translateX(0) scale(1); opacity: 1; }
    70% { transform: translateX(0) scale(1); opacity: 1; }
    80% { transform: translateX(0) scale(.75); opacity: 1; }
    to { transform: translateX(-100vw) scale(.75); opacity: .5; }
}
@keyframes messagewrapper {
    from { opacity: 0; }
    5% { opacity: 1; }
    95% { opacity: 1; }
    to { opacity: 0; }
}

:root {
    --font-body: 'Major Mono Display', "Helvetica Neue", Arial, sans-serif;
    --font-title: 'Vampiro One', 'Impact', cursive;
    --accent: gold;
    --skew: skewY(-3deg) scaleX(.85);
    --aside: 40px;
}
body, h1, h2, h3, p, small, span {
    margin: 0;
    padding: 0;
}
body {
    overflow: hidden;
    background: black;
    font-family: var(--font-body);
}
main {
    max-width: 100%;
    max-height: 100%;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
    background: #111;
    overflow: hidden;
}
header {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
    background: rgba(0,0,0,.85);
    color: white;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: opacity .4s;
}
aside {
    width: 100%;
    height: var(--aside);
    background: #333;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 1em;
    box-sizing: border-box;
    color: white;
}
canvas {
    position: relative;
    image-rendering: -moz-crisp-edges;
    image-rendering: -webkit-crisp-edges;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
}
a {
    color: inherit;
    text-decoration: none;
    transition: color .5s;
}
a:hover {
    color: var(--accent);
}
h1, button {
    font-family: var(--font-title);
    font-size: 10vmin;
    transform: var(--skew);
    text-shadow: -2px 2px 0 var(--accent);
    text-align: center;
    line-height: .8em;
}
small {
    font-size: .75em;
    opacity: .5;
}
h1 small {
    opacity: 1;
}
button {
    transform: var(--skew) scale(.9);
    color: white;
    font-size: 3em;
    background: transparent;
    border: none;
    margin: 100px 0 60px 0;
    padding-bottom: .5em;
    overflow: visible;
    -webkit-appearance: none;
    appearance: none;
    cursor: pointer;
    transition: all 1s;
    animation: playbutton 3s infinite;
}
button:hover {
    font-size: 3.5em;
    color: var(--accent);
    text-shadow: -2px 2px 0 red;
}
p {
    max-width: 450px;
    text-align: center;
    line-height: 1.5em;
}
p small {
    line-height: 1em;
    padding: 1em 0;
    display: block;
}
code {
    display: inline-block;
    background: rgba(255,255,255,.2);
    padding: 3px 6px;
    border: 1px solid rgba(255,255,255,.2);
    line-height: 1em;
}

.message {
    --duration: 2s;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,.5);
    z-index: 5;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    animation: messagewrapper var(--duration);
    color: white;
    animation-direction: both;
}
.message > * {
    display: block;
    text-align: center;
    animation: message var(--duration);
    animation-direction: both;
}
.message strong {
    font-family: var(--font-title);
    font-size: 2em;
}
.conversation {
    --padd: 30px;
    position: absolute;
    top: var(--padd);
    left: var(--padd);
    width: calc(100% - var(--padd) * 2);
    background: black;
    color: white;
    font-size: 20px;
    border: 1px solid white;
    padding: 20px;
    box-sizing: border-box;
}
.conversation i {
    animation: fadein .4s;
    animation-fill-mode: backwards;
    font-style: normal;
    font-weight: 200;
}
.playing header {
    opacity: 0;
    pointer-events: none;
}

#progress-visualiser,
#control-visualiser {
    width: 100%;
    height: 1em;
    background: url('data:image/svg+xml;charset=utf8,<svg viewBox="0 0 1 1" xmlns="http://www.w3.org/2000/svg" preserveAspectRatio="none"><rect width="1" height="1" x="0" y="0" fill="white" stroke="none" /></svg>') no-repeat 0 0 / calc(var(--progress, .5) * 100%) 100% rgba(255,255,255,.2);
    margin-left: 20px;
}
#control-visualiser {
    background: none;
    position: relative;
    z-index: 0;
}
#control-visualiser:before {
    content: '';
    width: 100px;
    height: 100px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%) rotateZ(calc(var(--scroll) * 180deg));
    border: 10px solid red;
    border-left-color: yellow;
    border-bottom-color: green;
    border-right-color: blue;
    z-index: -1;
    border-radius: 50%;
}
#health-visualiser {
    width: calc(var(--max) * 1em);
    display: flex;
    align-items: left;
}
#health-visualiser i {
    width: .75em;
    height: 1em;
    margin-left: .25em;
    display: block;
    background: orange;
}
</style>

<script>

class CanvasTransform {

    constructor( x = 0, y = 0, rotation = 0, scale = 1 ){

        this.x = x;
        this.y = y;
        this.rotation = rotation;
        this.scale = scale;
        this.data = {};

    }

}
class CanvasObject extends CanvasTransform {

    constructor( width = 100, height = 100, x, y, rotation, scale ){

        super( x, y, rotation, scale );

        this.canvas = document.createElement( 'canvas' );
        this.context = this.canvas.getContext( '2d' );
        this.width = this.canvas.width = width;
        this.height = this.canvas.height = height;
        this.zIndex = 0;
        this.opacity = 1;
        this.debug = null;
        this.visible = true;
        this.centerOffset = { x: 0, y: 0 };

        return this;

    }

    overlaps( otherObject ){

    }

}
class CanvasScene extends CanvasObject {

    constructor( width = innerWidth, height = innerHeight ){

        super( width, height );

        this.children = [];
        this.clearOnRender = true;

        return this;

    }

    render(){

        if( this.clearOnRender ){

            this.canvas.width = this.canvas.width;

        }

        const { context } = this;

        this.children.sort((a,b) => a.zIndex - b.zIndex).filter(v => v.visible).forEach(child => {
            
            if( child instanceof CanvasScene ){

                child.render();

            }

            context.save();
            context.globalAlpha = child.opacity;
            context.translate( child.x, child.y );
            context.scale( child.scale, child.scale );
            context.rotate( child.rotation );
            context.drawImage( child.canvas, child.centerOffset.x, child.centerOffset.y, child.width, child.height );

            if( child.debug ){

                context.strokeStyle = child.debug;
                context.strokeRect( child.centerOffset.x, child.centerOffset.y, child.width, child.height );

            }

            context.restore();

        });

        return this;

    }
    callAll( method, ...args ){

        this.children.forEach(child => {

            if( child[method] ){
                
                child[method].apply( child, args );

            }

            if( child.callAll ){

                child.callAll( method, ...args );

            }

        })

    }

}
class CanvasSprite extends CanvasObject {

    constructor( width = 100, height = 100, x, y, rotation, scale ){

        super( width, height, x, y, rotation, scale );

        return this;

    }

    loadPatternFromURL( url, repeat = 'repeat' ){

        const image = new Image;

        image.addEventListener( 'load', e => {

            if( repeat === 'repeat-x' ) this.height = this.canvas.height = image.naturalHeight;
            if( repeat === 'repeat-y' ) this.width = this.canvas.width = image.naturalWidth;

            this.context.save();
            this.context.fillStyle = this.context.createPattern( image, repeat );
            this.context.fillRect( 0, 0, this.width, this.height );
            this.context.restore();

        });
        image.addEventListener( 'error', e => console.error( url, e ) );
        image.src = url;

        return this;

    }
    loadImageFromURL( url, computeOffset = false ){

        const image = new Image;

        image.addEventListener( 'load', e => {

            // this.width = this.canvas.width = image.naturalWidth || image.width;
            // this.height = this.canvas.height = image.naturalHeight || image.height;
            this.context.drawImage( image, 0, 0, this.width, this.height );

            if( computeOffset ){

                this.centerOffset.x = -this.width / 2;
                this.centerOffset.y = -this.height / 2;

            }

        });
        image.src = url;

        return this;

    }
    loadImageFromColor( color ){

        this.context.save();
        this.context.fillStyle = color;
        this.context.fillRect( 0, 0, this.canvas.width, this.canvas.height );
        this.context.restore();

        return this;

    }
    loadCircleFromColor( color ){

        const radius = Math.min( this.canvas.width, this.canvas.height ) / 2;

        this.context.save();
        this.context.fillStyle = color;
        this.context.beginPath();
        this.context.arc( this.canvas.width / 2, this.canvas.height / 2, radius, 0, Math.PI * 2 );
        this.context.fill();
        this.context.restore();

        return this;

    }
}
class CanvasPlayer extends CanvasScene {

    constructor( width, height, x = 0, y = 0, rotation = 0, scale = 1 ){

        super( width, height );

        this.x = x;
        this.y = y;
        this.rotation = rotation;
        this.scale = scale;
        this.centerOffset.x = -width / 2;
        this.centerOffset.y = -height / 2;

        this.children.push(
            new CanvasSprite( width, height, 0, 0, 0, 1 ).loadImageFromURL( 'images/cruddyship-rect.svg' )
        );

        this.controllable = true;
        this.angular = 0;
        //this.loadImageFromURL( 'images/cruddyship.png', true );

    }

}

class CanvasResetLevel extends CanvasSprite {

    onOverlap(){

        reset();

    }

}
class CanvasPickup extends CanvasSprite {

    constructor( image, x, y, respawnTime ){

        super( 60, 60, x, y );

        this.respawnTime = respawnTime;
        this.loadImageFromURL( image );

    }

    onCollect( overlapTarget ){

        // require implementation of subclasses

    }
    onOverlap( overlapTarget ){

        if( this.visible ){

            this.visible = false;
            this.onCollect( overlapTarget );

            const pickUpCount = PICKUP_COUNTER.get( this.constructor ) + 1;

            if( this.constructor.FIRST_PICKUP_PHRASE && pickUpCount === 1 ){

                displayConversation( this.constructor.FIRST_PICKUP_PHRASE );

            }

            PICKUP_COUNTER.set( this.constructor, PICKUP_COUNTER.get( this.constructor ) + 1 );

            if( this.respawnTime ) setTimeout(() => {

                this.visible = true;

            }, this.respawnTime)

        }

    }

}
class CanvasResetScalePickup extends CanvasPickup {

    constructor( ...args ){

        super( './images/scale.png', ...args );

    }

    onCollect( overlapTarget ){

        overlapTarget.scale = 1;

        setTimeout(() => this.visible = false, 2000)

    }
    
}
class CanvasResetSpeedPickup extends CanvasPickup {

    constructor( ...args ){

        super( './images/time.png', ...args );

    }

    onCollect( overlapTarget ){

        speed = speedDefault;

    }

    static get FIRST_PICKUP_PHRASE(){

        return "Oh, some coolant for the engine!";

    }

}
class CanvasHealthPickup extends CanvasPickup {

    constructor( ...args ){

        super( './images/health.png', ...args );

    }

    onCollect( overlapTarget ){

        health++;

    }

    static get FIRST_PICKUP_PHRASE(){

        return "Ahh, this will patch some holes in the ship!";

    }

}
class CanvasPointsPickup extends CanvasPickup {

    constructor( ...args ){

        super( './images/points.png', ...args );

    }

    onCollect( overlapTarget ){

        points += 100;

    }

    static get FIRST_PICKUP_PHRASE(){

        return "Don't know what these do. They might be valuable.";

    }

}
class CanvasLevelFloor extends CanvasSprite {

    onOverlap( overlapTarget ){
        
        overlapTarget.y = this.y - overlapTarget.height * overlapTarget.scale - overlapTarget.centerOffset.y;
        speed = clamp( speed - .01, 1, Infinity );

    }

}
class CanvasRandomisedLevel extends CanvasScene {

    constructor( width, height ){

        super( width, height );

        this.construct();

    }

    construct(){

        const objects = [];
        const pickups = [ CanvasResetSpeedPickup, CanvasPointsPickup, CanvasHealthPickup ];
        const background = new CanvasSprite( this.width, this.height ).loadPatternFromURL( './images/background.png', 'repeat' );

        // top and bottom respectively
        this.children = [];
        this.children.push(
            background,
            new CanvasBounceOffWall( this.width, 32 ).loadPatternFromURL( './images/top.png', 'repeat-x' ),
            new CanvasLevelFloor( this.width, 32, 0, this.height - 32 ).loadPatternFromURL( './images/bottom.png', 'repeat-x' ),
            new CanvasEndLevelZone( scene.width, this.height, this.width - scene.width, 0 ).loadImageFromURL( './images/landingpad.png' ),
        );
        
        background.onUpdate = () => background.opacity = 1 - clamp(Math.abs(level.x) / level.width, 0, 1);
        background.zIndex = -5;

        for( let x = scene.width * 1.5, i = 0; x < this.width - scene.width * 2; i++ ){
            
            let t = Math.random() < .5;
            let h = Math.random() * 250 + 50;
            let y = t ? this.height - h : 0;
            let w = Math.random() * 50 + 50;
            let r = t ? './images/rock-bottom.png' : './images/rock-top.png';

            switch( Math.floor(Math.random() * 2) ){
                case 0:
                    // first is always a speed boost
                    if( i !== 0 ){
                        
                        this.children.push( new CanvasBounceOffWall( w, h, x, y ).loadImageFromURL( r ) );

                        y = (this.height - h) * .5;
                        y = t ? y : y + h;

                        const thing = pickups[ Math.floor(Math.random() * pickups.length)];
                        
                        this.children.push( new thing( x + w / 2, y ) );
                        break;

                    }
                case 1:
                    this.children.push( new SpeedUpStrip( x ) );
                    break;

            }

            x += Math.random() * 600 + 400;

        }
    
    }

}
class CanvasBounceOffWall extends CanvasSprite {

    constructor(){

        super( ...arguments );

        this.lastHit = 0;

    }

    onOverlap( overlapTarget ){

        const now = Date.now();

        if( now - this.lastHit > 1000 && --health === 0 ){

            if( health === 0 ){

                this.lastHit = Date.now() + 1000;
                
                const explosion = new Explosion( 200, 200 );

                controllable = false;
                explosion.x = player.x;
                explosion.y = player.y;
                player.visible = false;
                scene.children.push( explosion );
                explosion.play();

                displayConversation( "We're not going to make it!" ).then(() => {

                    displayMessage( "Game Over" ).then( reset );

                    whentrue(() => explosion.visible === false).then(() => {

                        deleteFromScene( scene, explosion );

                    });

                });

                return;

            }

        }

        if( now - this.lastHit > 200 ){

            explosion.x = player.x;
            explosion.y = player.y;
            explosion.play();

            if( Math.random() < .5 ){

                displayConversation( CanvasBounceOffWall.BUMP_STRINGS[ Math.floor(Math.random() * CanvasBounceOffWall.BUMP_STRINGS.length) ] );

            }

            if( overlapTarget.y > this.y ){

                overlapTarget.rotation += Math.PI / 4;
                overlapTarget.angular = Math.PI;

            } else {

                overlapTarget.rotation -= Math.PI / 4;
                overlapTarget.angular = -Math.PI * 4;

            }
            
            this.lastHit = now;

        }

    }

    static get BUMP_STRINGS(){

        return [
            "Watch out for that!",
            "We're not going to survive for long like this...",
            "Oh no!",
            "Would you mind not doing that?"
        ];

    }

}
class CanvasEndLevelZone extends CanvasSprite {

    constructor(){

        super( ...arguments );

    }

    onOverlap( overlapTarget ){

        controllable = false;
        playing = false;

        const since = Date.now();
        const from = { x: player.x, y: player.y, rotation: player.rotation % RADIAN };
        const to = { x: scene.width / 2, y: scene.height - player.width, rotation: -Math.PI / 2 }

        function toEnd(){

            return new Promise(resolve => {
                
                function doIt(){

                    const progress = clamp( (Date.now() - since) / 2000, 0, 1 );
                    const p = progress * progress;

                    if( progress === 1 ){

                        Object.assign( player, to );
                        controllable = true;

                        resolve();

                    } else {

                        Object.assign( player, {
                            x: (to.x - from.x) * progress + from.x,
                            y: (to.y - from.y) * p + from.y,
                            rotation: (to.rotation - from.rotation) * p + from.rotation,
                        });
                        window.requestAnimationFrame( doIt );

                    }

                }
                
                doIt();

            });

        }

        const text = displayConversation( "There's the landing pad!" ).then(() => {

            return displayConversation( "We made it!!" );

        });
        const end = toEnd();

        Promise.all([ text, end ]).then(() => {

            displayMessage( `Your score: <span style="color:var(--accent);">${points}</span>` ).then(() => {

                document.body.classList.remove( 'playing' );
                setTimeout( reset, 1000 );

            });

        });

    }

}
class Explosion extends CanvasScene {

    constructor( width = 100, height = 100, x = 0, y = 0 ){

        super( width, height );

        const w = width / 2;
        const h = height / 2;

        this.x = x;
        this.y = y;
        // this.centerOffset.x = -width / 2;
        // this.centerOffset.y = -height / 2;
        this.startTime = -1;
        this.visible = false;
        this.duration = 500;
        this.children.push(
            new CanvasSprite( w, h, w / 2, h / 2 ).loadCircleFromColor( 'gold' ),
            new CanvasSprite( w, h, w + w / 2, h / 2 ).loadCircleFromColor( 'yellow' ),
            new CanvasSprite( w, h, w / 2, h + h / 2 ).loadCircleFromColor( 'gold' ),
            new CanvasSprite( w, h, w + w / 2, h + h / 2 ).loadCircleFromColor( 'yellow' ),
            new CanvasSprite( width, height, w, h ).loadCircleFromColor( 'rgba(255,0,0,.85)' )
        );
        this.children.forEach(child => {
            
            child.data.origin = { x: child.x, y: child.y };
            child.centerOffset.x = -child.width / 2;
            child.centerOffset.y = -child.height / 2;
            child.visible = false
        
        });

        return this;

    }

    render(){

        super.render();

    }

    play(){

        if( !this.visible ){

            this.visible = true;
            this.children.forEach(child => {
                child.x = child.data.origin.x + (Math.random() * 2 - 1) * (this.width * .15);
                child.y = child.data.origin.y + (Math.random() * 2 - 1) * (this.height * .15);
                child.visible = true
            });
            this.startTime = Date.now();
            this.onUpdate();

        }

        return this;

    }
    stop(){

        this.visible = false;
        this.children.forEach(child => child.visible = false);

    }

    onUpdate(){

        if( this.visible ){

            const progress = clamp( (Date.now() - this.startTime) / this.duration, .001, 1 );
            const p = progress;
            const o = -Math.pow( -1 + 2 * p, 2 ) + 1;

            this.children.forEach(child => {
                
                child.scale = p;
                child.opacity = o;
            
            });

            if( p === 1 ){

                this.stop();

            }

        }

    } 

}
class SpeedUpStrip extends CanvasSprite {

    constructor( x ){

        super( 200, scene.height * 2, x, -scene.height / 2 );

        this.zIndex = -1;
        this.lastTrigger = -1;
        this.loadImageFromColor( 'yellow' );

    }

    onOverlap(){

        if( !overlaps.has( this ) ){

            if( this.lastTrigger === -1 ){
                
                this.lastTrigger = 1;
                this.loadImageFromColor( 'gold' );

            } else {
                
                this.lastTrigger = -1;
                this.loadImageFromColor( 'yellow' );

            }

            speed = clamp( speed + this.lastTrigger, 1, Infinity );

        }

    }

    onUpdate(){



    }

}
class SmokePuff extends CanvasSprite {

    constructor( width = 100, height = 100, x = 0, y = 0 ){

        super( width, height, x, y, 0, 1 );

        const g = Math.floor(Math.random() * 200) + 55;
        const alpha = Math.random();

        this.centerOffset.x = -width / 2;
        this.centerOffset.y = -height / 2;
        this.loadCircleFromColor( `rgba(${g},${g},${g},${alpha})` );

    }

    onUpdate(){

        this.opacity = clamp( this.opacity - delta / 1000, 0, 1 );

        if( this.opacity <= 0 ) this.visible = false;

    }

}

function displayConversation( text, speed = 40 ){

    text.split( ' ' ).map(v => `<i>${v}</i>`).join(' ');
    
    return conversationPromise = conversationPromise.then(() => new Promise(resolve => {

        const dom = mainWrapper.appendChild( document.createElement( 'div' ) );

        dom.className = 'conversation';
        dom.innerHTML = '';

        const texts = text.split( ' ' );

        for( let i = 0; i < texts.length; i++ ){

            const _dom = document.createElement( 'i' );

            _dom.innerText = texts[i] + ' ';
            _dom.style.animationDuration = speed + 'ms';
            _dom.style.animationDelay = 400 + (i+1) * speed + 'ms';

            dom.appendChild( _dom );

        }
        
        new Promise(r => setTimeout( r, 2000 + speed * texts.length )).then(() => {

            dom.remove();
            resolve();

        });

        window.addEventListener( 'click', e => {

            dom.remove();
            resolve();

        }, { once: true });

    }));

}
function displayMessage( message ){

    return conversationPromise = conversationPromise.then(() => new Promise(resolve => {

        const dom = mainWrapper.appendChild( document.createElement( 'div' ) );

        dom.className = 'message';
        dom.innerHTML = `<strong>${message}</strong>`;
        dom.addEventListener( 'animationend', e => {

            dom.remove();
            resolve();

        });

    }));

}
function deleteFromScene( scene, child ){

    const children = new Set( scene.children );

    children.delete( child );

    scene.children = Array.from( children );

    return scene;
    
}
function whentrue( check ){

    return new Promise(resolve => {

        function test(){

            const result = check();

            if( result ){

                resolve( result );

            } else {
                
                window.requestAnimationFrame( test )

            };

        }

        window.requestAnimationFrame( test )

    })

}
function randomPuffOffSmoke(){

    const x = player.x;
    const y = player.y + Math.random() * 20 - 10;
    const r = Math.random() * player.width / 4 + player.height / 4;
    const sprite = new SmokePuff(
        r,
        r,
        player.x - level.x,
        player.y - level.y
    );
    const duration = Math.random() * 500 + 500;

    setTimeout(function(){

        if( playing && controllable ){
            
            level.children.push( sprite );

            whentrue(() => sprite.visible === false).then(() => {

                deleteFromScene( level, sprite );

            });

        }

        setTimeout( randomPuffOffSmoke, Math.random() * 500 );

    }, Math.random() * 100);

}
function randomExplosion(){

    if( playing && controllable ){

        // Select a random part, then remove it from the possibilities until we run out.

        if( shipPartStrings.length === 0 ) shipPartStrings.push( ...SHIP_PART_STRINGS );

        const randomPartOfShip = shipPartStrings[ Math.floor(Math.random() * shipPartStrings.length) ];

        shipPartStrings = new Set( shipPartStrings );
        shipPartStrings.delete( randomPartOfShip );
        shipPartStrings = Array.from( shipPartStrings );

        displayConversation( `Oh no, our ${randomPartOfShip} has given out!` ).then(() => {

            const dir = (Math.random() < .5 ? -1 : 1);

            explosion.x = player.x;
            explosion.y = player.y + (player.height * .25 * dir);
            explosion.zIndex = 2;
            explosion.play();
            explosion.scale = Math.random() * .5 + .5;

            whentrue(() => Date.now() - explosion.startTime > explosion.duration * .5).then(() => {

                player.rotation += dir;
                speed = clamp( speed * .8, 1, Infinity );

                setTimeout( randomExplosion, Math.random() * 5000 + 5000 );
                //scroll.y = 100 + Math.random() * 100 * (Math.random() < .5 ? -1 : 1);

            });

        });

    } else {

        setTimeout( randomExplosion, Math.random() * 5000 + 1000 );
        
    }

}
function getBoundingBox( ofObject ){

    return {
        left: ofObject.x + ofObject.centerOffset.x,
        right: ofObject.x + ofObject.centerOffset.x + ofObject.width * ofObject.scale,
        top: ofObject.y + ofObject.centerOffset.y,
        bottom: ofObject.y + ofObject.centerOffset.y + ofObject.height * ofObject.scale
    };

}
function clamp( value, min, max ){
    
    return value < min ? min : (value > max ? max : value);
    
}
function canvasTouchEventToOffset( touchEvent, touch = touchEvent ){

    const bb = touch.target.getBoundingClientRect();

    return {
        x: (touch.clientX - bb.left) / bb.width * touchEvent.target.width,
        y: (touch.clientY - bb.top) / bb.height * touchEvent.target.height
    }

}
function canvasMouseEventToOffset( mouseEvent ){

    return {
        x: mouseEvent.offsetX / mouseEvent.target.clientWidth * mouseEvent.target.width,
        y: mouseEvent.offsetY / mouseEvent.target.clientHeight * mouseEvent.target.height
    }

}
function updateLevel(){

    const direction = Math.sign( Math.cos( player.rotation ) );

    level.x = clamp( level.x - direction * speed, -level.width + scene.width, 0 );

    level.children[0].opacity = 1 - Math.abs(level.x) / level.width;
    // if( level.x > 0 ){

    //     level.x = -level.width + scene.width;

    // }

    // if( level.x < -level.width + scene.width ){

    //     resetLevel();

    // }

}
function updateUI(){

    pointsCounter.textContent = points;
    progressVisualiser.style.setProperty( '--progress', Math.abs(level.x) / (level.width - scene.width));

    if( healthVisualiser.children.length !== health ){

        let html = '';

        for( let i = 0; i < health; i++ ) html += `<i></i>`;

        healthVisualiser.style.setProperty( '--max', healthDefault );
        healthVisualiser.innerHTML = html;

    }

}
function detectOverlaps( withObject ){

    const withObjectBox = getBoundingBox( withObject );
    const _overlaps = level.children.filter(v => v.onOverlap).filter(child => {

        const box = getBoundingBox( child );
        
        box.left += level.x;
        box.right += level.x;
        box.top += level.y;
        box.bottom += level.y;

        return !( 
            withObjectBox.left   > box.right
            || withObjectBox.top    > box.bottom
            || withObjectBox.bottom < box.top
            || withObjectBox.right  < box.left
        );

    });

    _overlaps.forEach(child => child.onOverlap( withObject ));

    overlaps.clear();

    _overlaps.forEach(child => overlaps.add( child ));


    return overlaps;

}
function reducePlayerAngular( amount ){

    if( player.angular != 0 ){

        const abs = Math.abs(player.angular) - amount;

        if( abs < 0 ) player.angular = 0;

        player.angular = abs * Math.sign( player.angular );

    }

}
function updatePlayer(){

    player.x += Math.cos( player.rotation ) * speed;
    player.y += Math.sin( player.rotation ) * speed;

    player.x = clamp( player.x, 50, 150 );
    player.y = clamp( player.y, 50, 700 );

    //player.rotation = player.rotation % RADIAN;

    let scrollValue;

    if( Math.abs(scroll.x) > Math.abs(scroll.y) ){
        
        scrollValue = scroll.x / scroll.max;

    } else {

        scrollValue = scroll.y / scroll.max;

    }

    if( player.angular != 0 ){

        reducePlayerAngular( Math.PI / 200 );
        
        player.rotation += player.angular / 200;

    }

    controlVisualiser.style.setProperty( '--scroll', scrollValue );

    player.rotation += Math.PI * .005 * scrollValue;

    scroll.y *= .98;
    scroll.x *= .98;

    if( mouse.down ){

        reducePlayerAngular( Math.PI / 200 );

        //speed = clamp( speed + .1, speedDefault, 10 );

    } else {

        //player.y += 2;
        speed += delta / 15000;

    }

    Object.assign( mouse, nextMouse );

}
function gameLoop( t ){

    if( time === null ){

        time = t;
        return;

    } else {

        delta = t - time;
        time = t;

    }

    if( focused && playing ){
        
        if( controllable ){
            
            updateLevel();
            updatePlayer();
            detectOverlaps( player );
        
        }

    }

    if( focused ){
        
        scene.render();
        scene.callAll( 'onUpdate', scene );
    
    }
    
    window.requestAnimationFrame( gameLoop );

}
function resetPlayer(){

    player.x = 100;
    player.y = 300;
    player.scale = 1;
    player.rotation = 0;
    player.visible = true;

}
function resetLevel(){

    level.x = -level.width + scene.width * 1.5;
    level.children.forEach(v => v.visible = true);

    speed = speedDefault;

}
function reset(){

    document.body.classList.remove( 'playing' );

    resetPlayer();
    resetLevel();

    playing = false;
    level.x = 0;
    scroll.x = 0;
    scroll.y = 0;

    PICKUP_COUNTER.forEach((v,c) => PICKUP_COUNTER.set(c,0));
    
}
function start(){

    // Generate new level

    scene.children = scene.children.filter(l => l !== level);
    level = new CanvasRandomisedLevel( 10000, 600 );
    level.zIndex = 0;
    player.zIndex = 1;
    explosion.zIndex = 2;
    scene.children.push( level );

    // Reset all values

    reset();

    // Start playing and rendering

    document.body.classList.add( 'playing' );

    scene.render();

    playing = true;
    controllable = false;
    
    displayConversation( 'Oh no! Our ship is out of control, Isaac!' ).then(() => {

        displayConversation( 'Try to make it to the landing pad, Isaac!' ).then(() => {

            playing = true;
            controllable = true;

        });
        
    });

}

const TMP = { canvas: document.createElement( 'canvas' ) }
const RADIAN = Math.PI * 2;
const SHIP_PART_STRINGS = [
    'capacitor',
    'quantum propulsion expediator',
    'dark matter engine',
    'discombobulator',
    'fluctuator',
    'ioniser',
    'thing that goes "Pew, Pew Pew!"'
];
const PICKUP_COUNTER = new Map([
    [ CanvasHealthPickup, 0 ],
    [ CanvasPointsPickup, 0 ],
    [ CanvasResetSpeedPickup, 0 ]
]);

const mouse = { x: 0, y: 0, down: false, touch: null };
const scroll = { x: 0, y: 0, min: -100, max: 100 };
const nextMouse = { x: 0, y: 0 };
const scene = new CanvasScene( 800, 600 );
const player = new CanvasPlayer( 100, 50, 0, 0, 0, .25  );
const speedDefault = 2;
const healthDefault = 3;
const explosion = new Explosion;
const overlaps = new Set;

const mainWrapper = document.querySelector( 'main' );
const pointsCounter = document.getElementById( 'points-counter' );
const wrapper = document.getElementById( 'game' );
const progressVisualiser = document.getElementById( 'progress-visualiser' );
const healthVisualiser = document.getElementById( 'health-visualiser' );
const controlVisualiser = document.getElementById( 'control-visualiser' );

let level = new CanvasRandomisedLevel( 10000, 600 );
let playing = false;
let controllable = true;
let focused = true;
let speed = healthDefault;
let points = 0;
let thrusters = false;
let health = 3;
let delta = 0;
let time = 0;
let shipPartStrings = SHIP_PART_STRINGS.slice();
let conversationPromise = Promise.resolve();

scene.children.push( explosion );

setInterval( updateUI, 100 );

scene.children.push( player, level );
scene.render();

wrapper.appendChild( scene.canvas );

scene.canvas.addEventListener( 'mouseup', e => mouse.down = false );
scene.canvas.addEventListener( 'mousedown', e => mouse.down = true );
scene.canvas.addEventListener( 'mouseup', e => mouse.down = false );
scene.canvas.addEventListener( 'mouseleave', e => mouse.down = false );
scene.canvas.addEventListener( 'mousemove', e => Object.assign( mouse, canvasMouseEventToOffset( e ) ), { once: true });
scene.canvas.addEventListener( 'mousemove', e => Object.assign( nextMouse, canvasMouseEventToOffset( e ) ));
scene.canvas.addEventListener( 'touchstart', e => {
    
    if( !mouse.touch ){

        const location = canvasTouchEventToOffset( e, e.changedTouches[0] );
        
        mouse.touch = e.changedTouches[0].identifier;
        mouse.down = true
        Object.assign( mouse, location );
        Object.assign( nextMouse, location );
    
    }

});
scene.canvas.addEventListener( 'touchmove', e => {
    
    if( mouse.touch !== null ){
        
        const touch = Array.from( e.changedTouches ).find( v => v.identifier === mouse.touch);

        Object.assign( nextMouse, canvasTouchEventToOffset( e, touch ) );

        mouse.down = false;
    
    }

});
scene.canvas.addEventListener( 'touchend', e => {
    
    if( mouse.touch === e.changedTouches[0].identifier ){
        
        mouse.down = null;
    
    }

});

window.addEventListener( 'blur', e => focused = false );
window.addEventListener( 'focus', e => focused = true );
window.addEventListener( 'wheel', e => {

    e.preventDefault();
    
    scroll.x = clamp( scroll.x + e.wheelDeltaX, scroll.min, scroll.max );
    scroll.y = clamp( scroll.y + e.wheelDeltaY, scroll.min, scroll.max );

});

gameLoop();
randomExplosion();
randomPuffOffSmoke();

console.log( scene );

</script>

</body>
</html>